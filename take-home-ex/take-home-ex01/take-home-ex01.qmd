---
title: "Take-home Exercise 1"
date: "30 January 2023"
date-modified: "`r Sys.Date()`"
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

### Load all the relevant packages

```{r}
pacman::p_load(sf, tmap, tidyverse, maptools, raster, spatstat, tmap, funModeling)
```

### Load the Geospatial data from Humanitarian Data Exchange

We filter out everything else that is unnecessary outside of Osun

```{r}
NGA_wp_geo <- st_read(dsn = "data/geospatial", 
                layer = "nga_admbnda_adm2_osgof_20190417") %>% filter(ADM1_EN == "Osun") %>% st_transform(crs=26392)
```

::: callout-note
From the above, we can tell that Nigeria is currently in WGS84
:::

### Get information from Nigeria -\> OSUN state only

::: callout-note
For our analysis, we are only looking for Osun state, so we'll filter out unnecessary states at this stage
:::

```{r}
nga_wp_as <- read_csv("data/aspatial/nga_wp.csv") %>%
  filter(`#clean_country_name` == "Nigeria", `#clean_adm1` == "Osun")
```

### Check for duplicated rows

```{r}
NGA_wp_geo$ADM2_EN[duplicated(NGA_wp_geo$ADM2_EN)==TRUE]
```

::: callout-note
There are no duplicate rows, as we have filtered out only Osun States
:::

### Convert water point data into sf point features

We need to convert the aspatial data into an sf dataframe

Below function, we will create sfc object from existing wkt column

```{r}
nga_wp_as$Geometry = st_as_sfc(nga_wp_as$`New Georeferenced Column`)
nga_wp_as
```

### Convert into table into sf object using the original wgs 84 coordinate system

```{r}
wp_sf <- st_sf(nga_wp_as, crs=4326)
```

This function will convert it into Nigeria's projected coordinate system

```{r}
wp_sf <- wp_sf %>%
  st_transform(crs = 26392)
```

### Data Wrangling and Plotting of Water Point Data

Considering that we are mapping out the functional and non-functional water points, we will check the number of status clean and non status clean.

```{r}
freq(data = wp_sf,
     input = '#status_clean')
```

#### Rename column name from #status clean to status_clean and replace na with 'unknown' tag

Need to prepend dplyr because raster has a similar function

```{r}
wp_sf_nga <- wp_sf %>% 
  rename(status_clean = '#status_clean') %>%
  rename(clean_adm2 = '#clean_adm2') %>%
  dplyr::select(status_clean, clean_adm2) %>%
  mutate(status_clean = replace_na(
    status_clean, "unknown"))

```

### Extract functional and non-functional water points

```{r}
wp_functional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Functional",
             "Functional but not in use",
             "Functional but needs repair"))

wp_nonfunctional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned",
             "Abandoned",
             "Non-Functional due to dry season",
             "Non-Functional",
             "Non functional due to dry season"))

wp_unknown <- wp_sf_nga %>%
  filter(status_clean == "unknown")
```

### Remove all unused or unneeded columns:

```{r}
NGA_wp_geo <- NGA_wp_geo %>%
  dplyr::select(c(3:4, 8:9, ))
```

### Performing Point-in-Polygon count

```{r}
NGA_wp_count <- NGA_wp_geo %>% 
  mutate(`total_wp` = lengths(
    st_intersects(NGA_wp_geo, wp_sf_nga))) %>%
  mutate(`wp_functional` = lengths(
    st_intersects(NGA_wp_geo, wp_functional))) %>%
  mutate(`wp_nonfunctional` = lengths(
    st_intersects(NGA_wp_geo, wp_nonfunctional))) %>%
  mutate(`wp_unknown` = lengths(
    st_intersects(NGA_wp_geo, wp_unknown)))
```

### Deriving the Proportion of Functional to Non-Functional Water points

The visualization would be more effective as percentage would give a better story

```{r}
NGA_wp_count <- NGA_wp_count %>%
  mutate(pct_functional = wp_functional/total_wp) %>%
  mutate(pct_nonfunctional = wp_nonfunctional/total_wp)
```

::: panel-tabset
## Functional

```{r}
tm_shape(NGA_wp_count) +
  tm_fill("pct_functional",
          n = 10,
          style = "equal",
          palette = "Blues",
          legend.hist = TRUE) +
  tm_borders(lwd = 0.1,
             alpha = 1) +
  tm_layout(main.title = "Rate map of functional water point by LGAs in Osun",
            legend.outside = TRUE)
```

## Non-Functional

```{r}
tm_shape(NGA_wp_count) +
  tm_fill("pct_nonfunctional",
          n = 10,
          style = "equal",
          palette = "Blues",
          legend.hist = TRUE) +
  tm_borders(lwd = 0.1,
             alpha = 1) +
  tm_layout(main.title = "Rate map of functional water point by LGAs in Osun",
            legend.outside = TRUE)
```
:::

### Mapping all the water points on the map

```{r}
tmap_mode('view') +
  tm_shape(wp_sf_nga) +
  tm_dots(col="status_clean",
          size=0.01,
          border.lwd=0.5) + 
  tm_view(set.zoom.limits = c(9,16))
```

### Deriving the Kernel Density Maps of Functional/Non-Functional Water points

Convert sf dataframes into spatial class

```{r}
wp_func_spatial_class <- as_Spatial(wp_functional)
wp_nfunc_spatial_class <- as_Spatial(wp_nonfunctional)
wp_osun <- as_Spatial(NGA_wp_geo)
```

#### Check the type to convert to

::: callout-tip
All are spatial points except wp_osun with is polygon
:::

```{r}
wp_func_spatial_class
```

```{r}
wp_nfunc_spatial_class
```

```{r}
wp_osun
```

#### Convert into generic sp format

```{r}
wp_func_sp <- as(wp_func_spatial_class, "SpatialPoints")
wp_nfunc_sp <- as(wp_nfunc_spatial_class, "SpatialPoints")
wp_osun_sp <- as(wp_osun, "SpatialPolygons")
```

#### Convert the generic format into spatstat's ppp format

```{r}
wp_func_ppp <- as(wp_func_sp, "ppp")
wp_nfunc_ppp <- as(wp_nfunc_sp, "ppp")
```

#### Plot Planar Point

```{r}
plot(wp_func_sp)
```

#### Summary Statistics

```{r}
summary(wp_func_ppp)
```

```{r}
summary(wp_nfunc_ppp)
```

Check for duplicated points

```{r}
any(duplicated(wp_func_ppp))
```

```{r}
any(duplicated(wp_nfunc_ppp))
```

#### Creating the Osun Confines using owin object

```{r}
osun_owin <- as(wp_osun_sp, "owin")
```

```{r}
plot(osun_owin)
```

#### Combine Functional and Non-Functional Point Events Object and Owin Object

```{r}
wp_func_ppp_comb = wp_func_ppp[osun_owin]
wp_nfunc_ppp_comb = wp_nfunc_ppp[osun_owin]
```

```{r}
summary(wp_func_ppp_comb)
```

### Plot functional and non-functional points

```{r}
par(mfrow=c(1,2))
plot(wp_func_ppp_comb)
plot(wp_nfunc_ppp_comb)
```

#### Deriving the Kernel Density Map

```{r}
kde_wp_func_map <- density(wp_func_ppp_comb,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
kde_wp_nfunc_map <- density(wp_nfunc_ppp_comb,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
par(mfrow=c(1,2))
plot(kde_wp_func_map)
plot(kde_wp_nfunc_map)
```

#### Rescale to KM

```{r}
wp_func_ppp_comb.km <- rescale(wp_func_ppp_comb, 1000, "km")
wp_nfunc_ppp_comb.km <- rescale(wp_nfunc_ppp_comb, 1000, "km")
```

Rerun Density for both functional and non-functional water point:

```{r}
kde_wp_func_map.bw <- density(wp_func_ppp_comb.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")

kde_wp_nfunc_map.bw <- density(wp_nfunc_ppp_comb.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
```

```{r}
par(mfrow=c(1,2))
plot(kde_wp_func_map.bw)
plot(kde_wp_nfunc_map.bw)
```

#### Computing Kernel Density Estimation using automatic bandwidth selection method

From our hands-on exercise, we were given the choice of either using *bw.ppl* or *bw.diggle* or adaptive kernel density estimatation method. We were told that *bw.ppl* is recommended specifically if the patterns are comprised of mostly tight clusters and well-distributed, and adaptive density are used if the data points are sparse. From my observation during the plotting of the water points, there appears to be a few tight clusters all throughout Osun and appear to be well-distributed. In lieu of that observation, I will be going with *bw.ppl* algorithm to determine the fixed bandwidth.

**So, I will go with *bw.ppl* in this case.**

```{r}
kde_wp_func_map.ppl <- density(wp_func_ppp_comb.km, sigma=bw.ppl, edge=TRUE, kernel="gaussian")
kde_wp_nfunc_map.ppl <- density(wp_nfunc_ppp_comb.km, sigma=bw.ppl, edge=TRUE, kernel="gaussian")
```

#### KDE Functional Points

```{r}
plot(kde_wp_func_map.ppl, main = "bw.ppl")
```

#### KDE Non-Functional Points

```{r}
plot(kde_wp_nfunc_map.ppl, main = "bw.ppl")
```

### Convert KDE output into Grid object

```{r}
gridded_kde_wp_func_ppl <- as.SpatialGridDataFrame.im(kde_wp_func_map.ppl)
gridded_kde_wp_nfunc_ppl <- as.SpatialGridDataFrame.im(kde_wp_nfunc_map.ppl)
spplot(gridded_kde_wp_func_ppl)
```

```{r}
spplot(gridded_kde_wp_nfunc_ppl)
```

### Rasterise Layer so it can be mapped on tmap

```{r}
kde_wp_func_map_ppl_raster <- raster(gridded_kde_wp_func_ppl)
kde_wp_nfunc_map_ppl_raster <- raster(gridded_kde_wp_nfunc_ppl)
```

Check the RASTER

```{r}
kde_wp_func_map_ppl_raster
```

```{r}
kde_wp_nfunc_map_ppl_raster
```

Assign Nigeria Projection System (ESG: 26392)

```{r}
projection(kde_wp_func_map_ppl_raster) <- CRS("+init=EPSG:26392 +units=km")
projection(kde_wp_nfunc_map_ppl_raster) <- CRS("+init=EPSG:26392 +units=km")
```

#### Visualize functional/non-functional water point map output in TMAP:

::: panel-tabset
## Functional Water points

```{r}
  tm_basemap("OpenStreetMap") +
  tmap_mode('plot') + 
  tm_shape(kde_wp_func_map_ppl_raster) +
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), 
            frame = FALSE, 
            main.title="Functional Water Points",
            main.title.position = "center",
            main.title.size = 1)+
  tm_view(set.zoom.limits = c(12,16))
```

## Non-Functional Water points

```{r}
  tm_basemap("OpenStreetMap") +
  tmap_mode('plot') + 
  tm_shape(kde_wp_nfunc_map_ppl_raster) +
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), 
            frame = FALSE, 
            main.title="Non-Functional Water Points",
            main.title.position = "center",
            main.title.size = 1)+
  tm_view(set.zoom.limits = c(12,16))
```
:::

### Describe the spatial patterns revealed by the kernel density maps.

From the maps above, we can tell at first glance that the functional water points and non-functional water points are concentrated at a few points. Another interesting point of note are that most of the water point areas, regardless of functioning/non-functioning are situated on the northern side of the map, with one large cluster of non-functional water points at the center of Osun.

### Highlight the advantage of kernel density map over point map.

We will define the point plot of both the functional and non-functional water points to compare visualization.

::: panel-tabset
## Functional

```{r}
tmap_mode('view') +
  tm_shape(wp_functional) +
  tm_dots(col="status_clean",
          size=0.01,
          border.lwd=0.5) + 
  tm_view(set.zoom.limits = c(9,16))
```

## Non-Functional

```{r}
tmap_mode('view') +
  tm_shape(NGA_wp_geo) +
  tm_polygons() +
  tm_shape(wp_nonfunctional) +
  tm_dots(col="status_clean",
          size=0.01,
          border.lwd=0.5) + 
  tm_view(set.zoom.limits = c(9,16))
```

## Together

```{r}
tmap_mode('view') +
  tm_shape(NGA_wp_geo) +
  tm_borders() +
  tm_shape(wp_sf_nga) +
  tm_dots(col="status_clean",
          size=0.01,
          border.lwd=0.5) + 
  tm_view(set.zoom.limits = c(9,16))
```
:::

From one look at the point map, it's not immediately obvious where the clusters are as the water points are generally well-distributed across Osun. It is only after we look at the kernel density map that it becomes obvious and clearer that the functional water points are mostly concentrated on the north west of Osun, with small clusters of non-functional water points scattered throughout. This also supports our earlier exploratory analysis where it's revealed that Ede North and Ejigbo has a higher proportion of functioning water points, and central areas like Ife Central and Ifelodon are lacking functional ones.

From this map, we can prioritise areas that would need to be fixed, and also to investigate why certain LGA's have a higher cluster/proportion of non-functioning water points compared to others.

```{r}

```

### Second Order Spatial Point Patterns Analysis

Now that we have completed our spatial data analysis, it's time we look at some of the areas where there are particularly high clusters of functioning and non-functioning water points and determine whether they are randomly distributed or not.

For this, I have chosen two states each as identified in the kernel density map for areas with high cluster of functioning and non-functioning water points

**Functioning:**

1.  Ejigbo
2.  Ede North

**Non-Functioning:**

1.  Ifelodun
2.  Ife Central

#### Hypothesis:

H0: The distribution of the water points are randomly distributed

H1: The distribution of the water points are not randomly distributed

Confidence Level: 99%; Significance level: 1%/0.01

### Create our Owin Object for all the LGAs

```{r}

ejigbo_area = wp_osun[wp_osun$ADM2_EN == 'Ejigbo',] %>%
  as('SpatialPolygons') %>%
  as('owin')

ede_north_area = wp_osun[wp_osun$ADM2_EN == 'Ede North',]%>%
  as('SpatialPolygons') %>%
  as('owin')

ifelodun_area = wp_osun[wp_osun$ADM2_EN == 'Ifelodun',]%>%
  as('SpatialPolygons') %>%
  as('owin')

ife_central_area = wp_osun[wp_osun$ADM2_EN == 'Ife Central',]%>%
  as('SpatialPolygons') %>%
  as('owin')
```

```{r}
par(mfrow=c(2,2))
plot(ejigbo_area, main="Ejigbo")
plot(ede_north_area, main="Ede North")
plot(ifelodun_area, main="Ifelodun")
plot(ife_central_area, main="Ife Central")
```

#### Extract the relevant areas for the functioning/non-functioning water points

```{r}
#Functioning Water points
wp_func_ejigbo_ppp = wp_func_ppp[ejigbo_area]
wp_func_ede_north_ppp = wp_func_ppp[ede_north_area]

#Non-functioning
wp_nfunc_ifelodun_ppp = wp_nfunc_ppp[ifelodun_area]
wp_nfunc_ife_central_ppp = wp_nfunc_ppp[ife_central_area]
```

#### Rescale them

```{r}
wp_func_ejigbo_ppp.km = rescale(wp_func_ejigbo_ppp, 1000, "km")
wp_func_ede_north_ppp.km = rescale(wp_func_ede_north_ppp, 1000, "km")
wp_nfunc_ifelodun_ppp.km = rescale(wp_nfunc_ifelodun_ppp, 1000, "km")
wp_nfunc_ife_central_ppp.km = rescale(wp_nfunc_ife_central_ppp, 1000, "km")
```

#### Functioning Water points

```{r}
par(mfrow=c(1,2))
plot(wp_func_ejigbo_ppp.km, main="Ejigbo")
plot(wp_func_ede_north_ppp.km, main="Ede North")
```

#### Non-functioning Water point

```{r}
par(mfrow=c(1,2))
plot(wp_nfunc_ifelodun_ppp.km, main="Ifelodun")
plot(wp_nfunc_ife_central_ppp.km, main="Ife Central")
```

### Using the L Function for Functioning Water Points

We will use the L Function, Lest(), to measure the distribution of the spatial point patterns, in this case, our water points. If the lines are outside of the envelop, we can say that it's statistically significant with 99% confidence.

#### Ejigbo Study Area

```{r}
L_ejigbo = Lest(wp_func_ejigbo_ppp, correction="Ripley")
plot(L_ejigbo, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

#### Complete Spatial Randomness Test

```{r}
L_ejigbo.csr <- envelope(wp_func_ejigbo_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ejigbo.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

We can say that the distribution of functional water points are not randomly distributed, as we reject the null hypothesis and since they are above the red line, it means the distribution is geographically clustered.

#### Ede North Study Area:

```{r}
L_ede_north = Lest(wp_func_ede_north_ppp, correction="Ripley")
plot(L_ede_north, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

Complete Spatial Randomness Test

```{r}
L_ede_north.csr <- envelope(wp_func_ede_north_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ede_north.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

Similar results to the Ede North. The clusters of functioning water points are NOT random as we reject the null hypothesis.

Overall results seems to indicate that functioning water points are generally clustered around certain places. This indicates that there might be environmental reasons why the functioning water points are placed at where they are.

### Using the L Function for Non-Functioning Water Points

#### Ifelodun Study Area

```{r}
L_ifelodun = Lest(wp_nfunc_ifelodun_ppp, correction="Ripley")
plot(L_ifelodun, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")

```

**Complete Spatial Randomness Test**

```{r}
L_ifelodun.csr <- envelope(wp_nfunc_ifelodun_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ifelodun.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

#### Ife Central Study Area

```{r}
L_ife_central_area = Lest(wp_nfunc_ife_central_ppp, correction="Ripley")
plot(L_ife_central_area, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

**Complete Spatial Randomness Test**

```{r}
L_ife_central_area.csr <- envelope(wp_nfunc_ife_central_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ife_central_area.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

From the above results, we can say that the distribution of non-functioning water points are also not random. Which means there might be external reasons why non-functioning water points are clustered at these areas.

### Spatial Correlation Analysis

To confirm whether the spatial distribution of functional and non-functional water points are independent, we will be using the K-Function. We will applying this over the four states that I have previously discussed. (Ejigbo, Ede North, Ifelodun and Ife Central)

-   H0: The functional and non-functional water points are distributed randomly and spatially independent

-   H1: The functional and non-functional water points are distributed non-random and spatially dependent.

-   Confidence Level: 99%

Null hypothesis will be rejected.

**Recreating the Planar Point with both functional and non-functional water points**

```{r}
wp_ppp <- as_Spatial(wp_sf_nga) %>%
  as("SpatialPoints") %>%
  as("ppp")
```

```{r}
wp_ppp = wp_ppp[osun_owin]
```

```{r}
K_wp_ppp = Kest(wp_ppp, correction = "Ripley")
plot(K_wp_ppp, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

K-Cross for both functional and non-functional water points

```{r}
ejigbo_wp_ppp = wp_ppp[ejigbo_area]
plot(ejigbo_wp_ppp, main="Test", which.marks = "status_clean")
```

```{r}
Lcross_ejigbo.csr <- envelope(ejigbo_wp_ppp, 
                              i="Functional", 
                              j="Non-Functional",
                              correction="border",
                              nsim=99)
envelop()
plot(Lcross_ejigbo.csr, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```
