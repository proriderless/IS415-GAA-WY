---
title: "In-class Exercise 10: Geographic of accessibility"
date: "20 March 2023"
date-modified: "20 March 2023"
author: "Tan Wen Yang"
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

Load Package

```{r}
pacman::p_load(tmap, SpatialAcc, sf, 
               ggstatsplot, reshape2,
               tidyverse, fca)
```

Load the data

```{r}
mpsz <- st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE_NO_SEA_PL")
hexagons <- st_read(dsn = "data/geospatial", layer = "hexagons")
eldercare <- st_read(dsn = "data/geospatial", layer = "ELDERCARE")
```

Transform the CRS

```{r}
mpsz <- st_transform(mpsz, 3414)
eldercare <- st_transform(eldercare, 3414)
hexagons <- st_transform(hexagons, 3414)
```

Cleaning and updating attribute fields

```{r}
eldercare <- eldercare %>%
  select(fid, ADDRESSPOS) %>%
  rename(destination_id = fid,
         postal_code = ADDRESSPOS) %>%
  mutate(capacity = 100)
hexagons <- hexagons %>%
  select(fid) %>%
  rename(origin_id = fid) %>%
  mutate(demand = 100)

```

### Aspatial wrangling

Import distance matrix

```{r}
ODMatrix <- read_csv("data/aspatial/OD_Matrix.csv", skip = 0)
```

Convert thin to fat

```{r}
distmat <- ODMatrix %>%
  select(origin_id, destination_id, total_cost) %>%
  spread(destination_id, total_cost)%>%
  select(c(-c('origin_id')))
```

Convert meter to km

```{r}
distmat_km <- as.matrix(distmat/1000)
```

#### What if distance matrix does not exist

using continous method to derive distance matrix

```{r}
eldercare_coord <- st_coordinates(eldercare)
hexagon_coord <- st_coordinates(hexagons)
```

```{r}
EucMatrix <- SpatialAcc::distance(hexagon_coord, eldercare_coord, type="euclidean")
```

Convert to KM

```{r}
EucMatrix_km <- as.matrix(EucMatrix/1000)
```

### Computing Hansen's accessibility

```{r}
acc_Hansen <- data.frame(ac(hexagons$demand,
                            eldercare$capacity,
                            distmat_km, 
                            #d0 = 50,
                            power = 2, 
                            family = "Hansen"))
```

Rename as the original name is too long

```{r}
colnames(acc_Hansen) <- "accHansen"
```

Convert into tibble format

```{r}
acc_Hansen <- as_tibble(acc_Hansen)
```

Don't sort

```{r}
hexagon_Hansen <- bind_cols(hexagons, acc_Hansen)
```

### Visualising Hansen\'s accessibility

Extract map extend

```{r}
mapex <- st_bbox(hexagons)
```

The code chunk below uses a collection of mapping functions of tmap package to create a high cartographic quality accessibility to eldercare centre in Singapore.

```{r fig.width=12, fig.height=8}
tmap_mode("plot")
tm_shape(hexagon_Hansen,
         bbox = mapex) + 
  tm_fill(col = "accHansen",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: Hansen method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 6),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)

```

#### Statistical Visualization

In this section, we are going to compare the distribution of Hansen\'s accessibility values by URA Planning Region.

Firstly, we need to add the planning region field into *hexagon_Hansen* simple feature data frame by using the code chunk below.

```{r}
hexagon_Hansen <- st_join(hexagon_Hansen, mpsz, 
                          join = st_intersects)
```

Do a boxplot

```{r}
ggplot(data=hexagon_Hansen, 
       aes(y = log(accHansen), ##We will need log transform if value is too big for proper comparison
           x= REGION_N)) +
  geom_boxplot() +
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```

### Modelling and Visualising Accessibility using KD2SFCA Method

In this section, you are going to repeat most of the steps you had learned in previous section to perform the analysis. However, some of the codes will be combined into one code chunk.\
The code chunk below calculates Hansen\'s accessibility using *ac()* of **SpatialAcc** and *data.frame()* is used to save the output in a data frame called `acc_KD2SFCA`. Notice that `KD2SFCA` is used for family argument.

```{r}
acc_KD2SFCA <- data.frame(ac(hexagons$demand,
                            eldercare$capacity,
                            distmat_km, 
                            d0 = 50,
                            power = 2, 
                            family = "KD2SFCA"))

colnames(acc_KD2SFCA) <- "accKD2SFCA"
acc_KD2SFCA <- tbl_df(acc_KD2SFCA)
hexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)
```

Visualise KD2SFCA accessibility

```{r fig.width=12, fig.height=8}
tmap_mode("plot")
tm_shape(hexagon_KD2SFCA,
         bbox = mapex) + 
  tm_fill(col = "accKD2SFCA",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: KD2SFCA method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 6),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)
```

#### Statistical Graphic Visualization

```{r}
hexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, 
                          join = st_intersects)
```

Box Plot

```{r}
ggplot(data=hexagon_KD2SFCA, 
       aes(y = log(accKD2SFCA), 
           x= REGION_N)) +
  geom_boxplot() +
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```

Computing SAM accessibility

```{r}
acc_SAM <- data.frame(ac(hexagons$demand,
                         eldercare$capacity,
                         distmat_km, 
                         d0 = 50,
                         power = 2, 
                         family = "SAM"))

colnames(acc_SAM) <- "accSAM"
acc_SAM <- tbl_df(acc_SAM)
hexagon_SAM <- bind_cols(hexagons, acc_SAM)
```

Visualizing SAM accessibility

```{r fig.width=12, fig.height=8}
tmap_mode("plot")
tm_shape(hexagon_SAM,
         bbox = mapex) + 
  tm_fill(col = "accSAM",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: SAM method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 3),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)
```

Statistical Graphic Visualization

```{r}
hexagon_SAM <- st_join(hexagon_SAM, mpsz, 
                       join = st_intersects)
```

Box plot

```{r}
ggplot(data=hexagon_SAM, 
       aes(y = log(accSAM), 
           x= REGION_N)) +
  geom_boxplot() +
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```
